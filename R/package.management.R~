#' Create the md5 hash of an object
#' @description R's tools only allow one to create the md5 hash of a file.  This function takes an R object, creates a file, calculates the hash, deletes the file and returns the result.
#' @param obj Any R object that can be saved with the save command.
#' @export hash.obj
#' @return The md5 hash of an object
#' @author Alex
#' @examples
#' ## BENCHMARK
#' set.seed(1)
#' r <- rnorm(1e5)
#' r.md5 <- hash.obj(r)
#' names(r.md5) <- NULL
#' r.md5
#' ## END BENCHMARK
hash.obj <- function(obj)
{
  ## Every once in a while, floats cause problems.
  if( is.numeric(obj) ) obj <- round(obj,6)
  if( is.list(obj) )
  {
    for(j in 1:length(obj) )
    {
      if(is.numeric(obj) )
      {
        obj[[j]] <- round(obj[[j]], 6)
      }
    }
  }
  m.sum <- digest::digest(obj)
  return(m.sum)
}

#' Benchmark all functions in a package
#' @description This function goes through the entire namespace of a package, tests if there are benchmarks in the examples code and then runs those benchmarks.  The md5 hash of the function source code as well as the hashed results of any benchmarks are then stored in a new file
#' @inheritParams global_arguments (Include this IF one or more arguments are declared in the function global_arguments)
#' @export benchmark.package
#' @return Nothing yet.
#' @author Alex
generate.benchmarks <- function(verbose=FALSE,
                                write.loc = "~/pkg/pricemethodresearch/",
                                clean.dir = TRUE,
                                store.rda = FALSE,
                                pkg.name = "pricemethodresearch")
{

  if(clean.dir)system(paste0("rm ",write.loc,"/benchmarks/*"))

  fs = ls(as.environment(paste0("package:", pkg.name)))
  data(market_2)
  for(i in sample(1:length(fs)))  ## Random to ensure no serial dependence between outputs
  {
    str.f <- fs[i]

    f <- eval(parse(text = str.f))
    md5.f <- hash.obj(f)
    a <- suppressWarnings(example(str.f, package = pkg.name, character.only=TRUE, give.lines = TRUE))

    if(!is.null(a))
    {

      w.benchmark.start <- grep("## BENCHMARK",a)
      w.benchmark.stop <- grep("## END BENCHMARK",a)
      if(length(w.benchmark.start) > 0)
      {
        md5.out <- rep(NA, length(w.benchmark.start) + 1)
        md5.out[1] <- md5.f
        for(j in 1:length(w.benchmark.start))
        {
          
          if(verbose)print(paste("On Function",str.f, "benchmark",j))
          l.b <- (w.benchmark.start[j]+1):(w.benchmark.stop[j] - 1)
          b.code <- a[l.b]
          cat(paste0(paste(b.code,collapse="\n"),"\n"))
          eval(parse(text = paste0("f.temp <- function(){", paste(b.code, collapse="\n"),"}")))
          b.result <- f.temp()
          if(store.rda)
          {

          }
          md5.res <- hash.obj(b.result)
          md5.out[j + 1] <- md5.res
        }
      }else{
        md5.out <- md5.f
      }
    }else{
      md5.out <- md5.f
    }
    if(verbose){cat(paste0(paste(md5.out, collapse="\n"),"\n"))}
    
    f.out <- paste0(write.loc,"/benchmarks/",str.f)
    cat(paste0(paste(md5.out, collapse="\n"),"\n"), file = f.out, append = FALSE)
  }
}

#' Find the currently stored benchmarks and return them
#' @description For a given function, lookup the currently stored benchmarks and return them.
#' @param str.f The function name as a string
#' @param package.loc Where the source code for the package is, and benchmarks
#' @examples
#' ## BENCHMARK
#' a <- lookup.benchmarks("lookup.benchmarks")
#' a
#' ## END BENCHMARK
lookup.benchmarks <- function(str.f,
                           package.loc = "~/pkg/pricemethodresearch")
{
  f.current <- paste0(package.loc,"/benchmarks/",str.f)
  md5.benchmark <- NULL
  if(file.exists(f.current))
  {
    md5.benchmark <- readLines(f.current)
  }
  return(md5.benchmark)
}

#' Run the benchmark for a specific function and return relevant hashes
#' @description For a given function, compute the hash of the function source
#' as well as the hash of any associated benchmarks and return
#' @param str.f The function name as a string
#' @param package.loc Where the source code for the package is, and benchmarks
#' @param verbose Chatty
#' @examples
#' data(market_2)
#' ## BENCHMARK
#' a <- run.benchmarks("km")
#' a
#' ## END BENCHMARK
run.benchmarks <- function(str.f,
                           package.loc = "~/pkg/pricemethodresearch",
                           verbose = TRUE,
                           pkg.name = "pricemethodresearch")
{
  f <- eval(parse(text = str.f))
  md5.f <- hash.obj(f)
  a <- suppressWarnings(example(str.f, package = pkg.name, character.only=TRUE, give.lines = TRUE))

  if(!is.null(a))
  {
    
    w.benchmark.start <- grep("## BENCHMARK",a)
    w.benchmark.stop <- grep("## END BENCHMARK",a)
    if(length(w.benchmark.start) > 0)
    {
      md5.out <- rep(NA, length(w.benchmark.start) + 1)
      md5.out[1] <- md5.f
      for(j in 1:length(w.benchmark.start))
      {
        
        if(verbose)print(paste("On Function",str.f, "benchmark",j))
        l.b <- (w.benchmark.start[j]+1):(w.benchmark.stop[j] - 1)
        b.code <- a[l.b]
        if(verbose) cat(paste0(paste(b.code,collapse="\n"),"\n"))
        eval(parse(text = paste0("f.temp <- function(){", paste(b.code, collapse="\n"),"}")))
        b.result <- f.temp()
        md5.res <- hash.obj(b.result)
        md5.out[j + 1] <- md5.res
      }
    }else{
      md5.out <- md5.f
    }
  }else{
    md5.out <- md5.f
  }
  return(md5.out)
}
                           
#' Test a set of functions in memory against their pre-stored benchmarks
#' @description This just tests whether the current working version of a function
#' Lines up against its benchmark
#' @param str A vector of length n with the names of the functions you'd like to test
#' @param benchmark.loc The path where the package source code lives
#' @param verbose Tell me about your day
#' @return A vector of length n with the whether the benchmarks passed (TRUE) or at least one failed (FALSE) for each function
#' @examples
#' data(market_2)
#' ## BENCHMARK
#' km <- function(DF){return(DF)}
#' a <- test.benchmarks(str = "km") ## Should fail
#' a
#' ## END BENCHMARK
test.benchmarks <- function(pkg.name = "pricemethodresearch",
                            str = ls(as.environment(paste0("package:",pkg.name))),
                            benchmark.loc = "~/pkg/pricemethodresearch/",
                            verbose=TRUE)
{

  data(market_2)
  n <- length(str)
  res <- NULL

  for(i in 1:n)
  {
    str.f <- str[i]
    md5.out <- run.benchmarks(str.f, pkg.name = pkg.name)
    
    f.current <- paste0(benchmark.loc,"/benchmarks/",str.f)
    md5.benchmark <- NULL
    if(file.exists(f.current))
    {
      md5.benchmark <- readLines(f.current)
    }

    res[i] <- FALSE
    if(all.equal(md5.benchmark[-1],md5.out[-1]) == TRUE)
    {
      res[i] <- TRUE
    }
  }
  
  return(res)
}


#' Helper function to reduce the proftools call graph to limited namespace
#' 
#' @description This is a hack that takes an object from the proftools package and slims it down.  Basically the callgraph code in proftools included all sorts of R internals nonsense and had no option to reduce it.  This code does that, in a pretty aggressive way.  Unclear how this could be useful beyond the call.graph.setup routine.
#' @param p The p object crunched by proftools
#' @param e The environment agains which p should be reduced.
#' @inheritParams global_arguments (Include this IF one or more arguments are declared in the function global_arguments)
#' @export reduce.p
#' @return A new object with the exact same form as p, but with only those functions in e
#' @author Alex
#' @examples
#' data(market_95)
#' f <- "pr <- price.response(DF)"
#' pd <- prof.routine(f)
reduce.p <- function(p, e)
{
  f.include <- setdiff(c(ls(e),"FUN","lapply","mclapply"),c("prof.routine", "benchmark.package", "hash.obj"))
  sp <- strsplit(p$gNodes,"\n")
  f.p <- NULL
  for(i in 1:length(sp))
  {
    f.p[i] <- sp[[i]][1]
  }

  w.in <- which(f.p %in% f.include)
  n.in <- length(w.in)
  
  r <- list()
  r$nodes <- p$nodes[w.in]
  nms.in <- f.p[w.in]
  
  r$edges <- list()
  r$callCounts <- list()
  r$edgeL <- list()
  for(i in 1:n.in)
  {
    w <- w.in[i]
    res.i <- p$edges[[w]]
    c.i <- p$callCounts[[w]]
    w.i.in <- which(res.i %in% f.include)
    r$edgeL[[i]] <- list()
    
    if(length(w.i.in) > 0)
    {
      r$edges[[i]] <- res.i[w.i.in]
      r$callCounts[[i]] <- c.i[w.i.in]
      r$edgeL[[i]]$edges <- rep(NA, length(w.i.in))
      for(j in 1:length(w.i.in))
      {
        r$edgeL[[i]]$edges[j] <- which(nms.in == res.i[w.i.in[j]])
      }
    }else{
      r$edges[[i]] <- character(0)
      r$callCounts[[i]] <- NULL
      r$edgeL[[i]]$edges <- integer(0)
    }
  }

  r$gNodes <- p$gNodes[w.in]
  r$totalPercent <- p$totalPercent[w.in]
  r$selfPercent <- p$selfPercent[w.in]
  
  return(r)
}

#' A wrapper for proftools to profile a set of commands
#' @description This is a helper function to run a set of commands in an Rprof'ed session and return the profile data
#' @param f a string containing R code to be parsed and run.
#' @param rep An integer for the number of times to repear the f evaluation, helps capture fast routines
#' @export prof.routine
#' @return a proftools parse of the profile data
#' @author Alex
prof.routine <- function(f, rep = 1)
{
  tmp <- tempfile()
  Rprof(tmp)
  for(j in 1:rep)
  {
    benchmark.result <- eval(parse(text=f))
  }
  Rprof(NULL)
  pd <- readProfileData(tmp)
  return(pd)
}

#' Use the proftools output to create a call graph
#' @description Using the processed output from an Rprof session, this will create an graph object representing the call graph.  It is focused on a particular namespace and colors nodes according to their documentation/review states
#' 
#' @param pd The processed output of an Rprof session for a block of R code (see example)
#' @export pd
#' @returns A Rgraphviz rendered graph object
#' @author Alex
#' @examples
#' data(market_95)
#' f <- "pr <- price.response(DF)"
#' pd <- prof.routine(f)
#' g <- call.graph.setup(pd)
call.graph.setup <- function(pd)
{

  ##------ Load Environment ---------
  e <- as.environment("package:pricemethodresearch")
  ##---------------------------------
  
  ##------- Process profiling -------
  pd <- cvtProfileData(pd, TRUE, NA, 0)
  p <- np2x(pd, "none")
  p.new <- reduce.p(p,e)
  g <- g2g(p.new, FALSE)
  ##---------------------------------

  ##------- Node setup -------------
  shape = "ellipse"
  names(labels) <- labels <- graph::nodes(g)
  p$nodeColors <- rep("red",length(labels))
  names(p$nodeColors) <- labels
  for(i in 1:length(labels)) ## Find out if we have docs
  {
    a <- suppressWarnings(example(labels[i], package="pricemethodresearch", character.only=TRUE, give.lines = TRUE))
    if(!is.null(a)) p$nodeColors[i] <- "blue"
  }
  ##---------------------------------

  ##------- Edge setup ----------------
  edges <- graph::edgeL(g)
  edgeNames <- list()
  for (i in seq(along = edges))
  {
    if (length(edges[[i]]$edges) > 0)
    {
      edgeNames[[i]] <- paste(labels[i], labels[edges[[i]]$edges],sep = "~")
    }
  }
  edgeNames <- unlist(edgeNames)
  edgeCounts <- unlist(p.new$callCounts)
  anyEdges <- (length(edgeCounts) > 0)
  ##------------------------------------

  ##------ Setup Graph  ----------------
  attrs <- list(node = list(shape = shape, fixedsize = FALSE))
  attrs$graph <- list(rankdir = "TB")
  g <- Rgraphviz::layoutGraph(g, layoutType = "dot", attrs = attrs)
  graph::nodeRenderInfo(g) <- list(col = p$nodeColors)
  ##------------------------------------

  return(g)
}
